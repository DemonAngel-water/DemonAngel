[TOC]

# 1 多进程并发服务器

## 1.1 优点

1. 由操作系统进行调度，运行比较稳定强壮

2. 能够方便地通过操作系统进行监控和管理。例如对每个进程的内存变化状况，甚至某个进程处理什么web请求进行监控，同时可以通过给进程发送信号量，实现对应用的各种管理

3. 隔离性好

   一个进程出现问题只有杀掉它重启就可以，不影响整体服务的可用性

   很容易实现在线热部署和无缝升级

   不需要考虑线程安全问题

4. 充分利用多核CPU，实现并行处理

## 1.2 缺点

1. 内存消耗比较大，每个进程都独立加载完整的应用环境
2. cpu消耗偏高，高并发下，进程之间频繁进行上下文切换，需要大量的内存换页操作
3. 很低的io并发处理能力，只适合处理短请求，不适合处理长请求

# 2 多线程并发服务器

## 2.1 优点

1. 对内存的消耗小。线程之间共享整个应用环境，每个线程都比较小，一般不到1M
2. cpu上下文切换比较快
3. io的并发能力强。JavaVM可以轻松维护几百个并发线程切换开销，远高于多进程几十个并发进程的处理能力
4. 有效利用多核cpu进行并行计算

## 2.2 缺点

1. 不方便操作系统的管理
2. 由于存在对共享资源的操作，一旦出现“死锁”和线程阻塞，很容易使整个应用失去可用性

# 3 IO多路复用并发服务器

## 3.1 select

1. 支持跨平台，最大缺陷是单个进程打开的FD是有限的，由FD_SETSIZE设置，默认是1024。虽然可以调整，但是，描述符数量越大，效率将更低，调整的意义不大。
2. 对socket扫描时是线性扫描，及采用轮询方式，效率低
3. 需要维护一个存放大量FD的数据结构(==bitmap位图==)，使得用户空间和内核空间在传递数据结构时复制开销大
4. "水平触发"，不会丢失数据和事件
5. 同时在线的大量客户端有事件发生的可能很少，但还是需要遍历fdset，因此随着监视的描述符数量的增长，其效率也会线性下降。

## 3.2 poll

1. poll与select本质上没有区别，但poll没有最大连接数的限制
2. 大量的fd==数组==被整体复制于用户态和内核地址空间之间，不管这样的复制是不是有意义
3. “水平触发”，如果报告了fd后，没有被处理，下次poll时还会再次报告该id，不会丢失数据和事件

## 3.3 epoll

1. 是之前poll和select的增强版，epoll更灵活，没有描述符限制，能打开的fd远大于1024（1G的内存能监听约10万个端口）
2. “边缘触发”，事件通知机制，效率提升，最大的特点在于它只管你活跃的连接，而跟连接总数无关，而epoll对文件描述符的操作模式之一ET(边缘触发)是一种高效的工作方式，很大程度减少事件反复触发的次数，内核不会发送更多的通知（only once）

### 3.3.1 水平触发和边缘触发

#### 3.3.1.1 水平触发(缺省)

如果报告了fd后事件没有被处理或数据没有被全部读取，那么epoll会==立即==再报告该fd，如redis采用的是水平触发

#### 3.3.1.2 边缘触发

如果报告了fd后事件没有被处理或数据没有被全部读取，那么epoll会==下次==再报告该fd，如nginx采用的是边缘触发

# 4 并发服务器的比较

|         比较项         |                       多进程并发服务器                       |                       多线程并发服务器                       |               IO多路复用的并发服务器（select）               |
| :--------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|      是不是真并发      |                              是                              |                              是                              |                            伪并发                            |
|    服务器能不能阻塞    |                             可以                             |                             可以                             |          不可以（可以设置通信套接字为非阻塞来解决）          |
| 处理客户端业务的隔离性 |                              强                              |                              弱                              |                              弱                              |
|         并发数         |                           100以内                            |                           500以内                            |                  1021以内<br />1024(0,1,2)                   |
|      什么时候使用      | 长连接<br />实时业务/阻塞业务<br />隔离性要求高<br />并发个数较少 | 长连接<br />实时业务/阻塞业务<br />隔离性要求低<br />并发个数在500以内 | 短连接<br />非实时业务/非阻塞业务<br />没有隔离性要求<br />并发数有较高要求 |

## 4.1 短连接

客户端与服务器建立连接之后，发送一次数据就完成了一次请求，这时候双方都可以进行close操作（一般是客户端先close）

## 4.2 长连接

客户端与服务器建立连接，完成一次请求之后， 它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。

## 4.3 隔离性

并发事物之间的不感知

## 4.4 select、poll、epoll区别

|                | select                               | poll                                   | epoll                                                        |
| -------------- | ------------------------------------ | -------------------------------------- | ------------------------------------------------------------ |
| 支持最大连接数 | 1024(x86) or 2048(x64)               | 无上限                                 | 无上限                                                       |
| IO效率         | 每次调用进行线性遍历，时间复杂度O(N) | 每次调用进行线性遍历，时间复杂度为O(N) | 使用“事件”通知方式，每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到rdllist里面，这样epoll_wait返回的时候我们就拿到了就绪的fd。时间复杂度O(1) |
| fd拷贝         | 每次select都拷贝                     | 每次poll都拷贝                         | 调用epoll_ctl时拷贝进内核由内核保存，之后每次epoll_wait不拷贝 |





